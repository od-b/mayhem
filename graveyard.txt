Unused, changed, removed and/or deprecated code.
May or may not have functioned correctly. Most are also stored in the git somewhere
Source is noted as <"class or reference" @ "local filepath"> -> "description"


<Controllable @ modules/PG_SPRITES> -> old docstring
    ''' ### Controllable object
        * Supports a custom or generic trigger.
        * position        = Vec2(x, y)
        * size            = Vec2(w, h)
        * velocity        = Vec2                               : initial velocity
        * angle           = float                              : initial angle in radians
        * mass            = None | float ∈ [0.0, 1.0]          : level of applied gravity
        ---
        #### Optional parameters
        * max_velocity    = None | Vec2                        : change in position per frame
        * trigger_func    = None | Callable                    : optional function to call on a trigger, ex. collision
        * trigger_weight  = None | Vec2, x,y ∈ [-1.0, 1.0]     : parameter for the trigger
        ---
        #### Notes: 
        * x, y, w and h is stored in .rect
        * may have a trigger_func without trigger_weight, but not vice-versa
    '''

<Controllable @ modules/PG_SPRITES> -> early attempt at angle
    def _update_angle(self):
        ''' update target angle based on pressed keys '''

        if (self.dir_x == -1):
            if (self.dir_y == -1):
                # left + up
                self.target_angle = 45.0
            elif (self.dir_y == 1):
                # left + down
                self.target_angle = 135.0
            else:
                # only left
                self.target_angle = 90.0
        elif (self.dir_x == 1):
            if (self.dir_y == -1):
                # right + up
                self.target_angle = -45.0
            elif (self.dir_y == 1):
                # right + down
                self.target_angle = -135.0
            else:
                # only right
                self.target_angle = -90.0
        elif (self.dir_y == 1):
            # only down
            if (self.angle > 0):
                # shortest way down is to the left
                self.target_angle = 180
            else:
                # shortest way down is to the right
                self.target_angle = -180
        elif (self.dir_y == -1):
            # only up   --    use abs(selfangle)
            self.target_angle = 0
        else:
            # stay on current angle
            self.target_angle = self.angle

<Controllable @ modules/PG_SPRITES> -> velocity limiter. functioning, but clamp is faster
    # def limit_velocity(self):
    #     ''' check velocity, if needed clamps the velocity between min/max '''
    #     # if velocity.x/y is greater than the limit, clamp it
    #
    #     if (abs(self.velocity.x) > self.MAX_VELOCITY.x):
    #         if (self.velocity.x < 0):
    #             self.velocity.x = -self.MAX_VELOCITY.x
    #         else:
    #             self.velocity.x = self.MAX_VELOCITY.x
    #
    #     if (abs(self.velocity.y) > self.MAX_VELOCITY.y):
    #         if (self.velocity.y < 0):
    #             self.velocity.y = -self.MAX_VELOCITY.y
    #         else:
    #             self.velocity.y = self.MAX_VELOCITY.y

<Controllable @ modules/PG_SPRITES> -> max_velocity before control rework
    # self.MAX_VELOCITY: Vec2 = Vec2(
    #     float(config['weights']['max_velocity']),
    #     float(
    #         config['weights']['max_velocity']\
    #         + (self.MASS * config['weights']['max_velocity'])
    #     )
    # )

<Controllable @ modules/PG_SPRITES> -> first draft of image rotate transform. Functioning
    # def update_image_angle(self):
    #     ''' Rotate image to the correct angle. Create new rect and mask. '''
    #
    #     # get a new image by rotating the original image
    #     # not referring to the original image will result in catastrophic memory flooding
    #     # the constant of -45 is to correct for the fact that image is a triangle
    #     IMG = pg.transform.rotate(self.ORIGINAL_IMAGE, self.angle)
    #     # flip y-axis of image (pygame y-axis is reversed)
    #     self.image = pg.transform.flip(IMG, False, True)
    #     # self.image = IMG
    #
    #     # get new mask for collision checking
    #     # > Note A new mask needs to be recreated each time a sprite's image is changed  
    #     # > (e.g. if a new image is used or the existing image is rotated).  
    #     #   https://www.pygame.org/docs/ref/sprite.html#pygame.sprite.collide_mask  
    #     self.mask = pg.mask.from_surface(self.image)
    #
    #     # set rect to the new images rect bounds
    #     # get_rect(**kwargs: Any) accepts a position value as parameter
    #     self.rect = self.image.get_rect(center=self.position)

<Controllable @ modules/PG_SPRITES> -> removed idea
    self.trigger_func: Callable | None = trigger_func
    ''' function to be called on update. 
        * Should not return a value
        * Pass attributes to be modified as parameters instead.
        * function must have exactly one parameter
    '''
    if self.trigger_func:
        self.trigger_func_param: any = None
        ''' parameter to be passed to the trigger_func.
            does nothing if trigger_func is not defined.
            * defaults to None
        '''

